### Chapter 9: Managing Dependencies in CMake

---

#### 1. Using Pre-Installed System Dependencies
**Key Concepts:**
- CMake's `find_package()` command locates pre-installed libraries/headers
- Two modes of operation: 
  - **Module Mode**: Uses `Find<Package>.cmake` scripts (manual dependency detection)
  - **Config Mode**: Uses `<Package>Config.cmake` files (auto-generated by many modern libraries)
- Common variables set by `find_package()`:
  - `<Package>_FOUND` (boolean indicating discovery status)
  - `<Package>_INCLUDE_DIRS` (header paths)
  - `<Package>_LIBRARIES` (library paths)

**Code Example: Find Boost**
```cmake
find_package(Boost 1.75 REQUIRED COMPONENTS filesystem system)

if(Boost_FOUND)
  add_executable(my_app main.cpp)
  target_link_libraries(my_app PRIVATE Boost::filesystem Boost::system)
endif()
```
- `REQUIRED` ensures CMake fails if Boost isn't found
- `COMPONENTS` specifies required Boost sub-libraries
- Modern CMake uses namespaced targets (`Boost::filesystem`)

---

#### 2. Writing Custom Find Modules
**Key Concepts:**
- Create `Find<Package>.cmake` files when libraries lack CMake support
- Core commands:
  - `find_path()`: Locate header directories
  - `find_library()`: Find compiled libraries
  - `mark_as_advanced()`: Hide variables from GUI

**Code Example: FindLibYAML.cmake**
```cmake
find_path(LIBYAML_INCLUDE_DIR yaml.h)
find_library(LIBYAML_LIBRARY NAMES yaml)

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(LibYAML DEFAULT_MSG 
  LIBYAML_LIBRARY LIBYAML_INCLUDE_DIR)

mark_as_advanced(LIBYAML_INCLUDE_DIR LIBYAML_LIBRARY)

if(LibYAML_FOUND)
  set(LIBYAML_LIBRARIES ${LIBYAML_LIBRARY})
  set(LIBYAML_INCLUDE_DIRS ${LIBYAML_INCLUDE_DIR})
endif()
```

**Usage in CMakeLists.txt:**
```cmake
list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
find_package(LibYAML REQUIRED)
target_include_directories(my_app PRIVATE ${LIBYAML_INCLUDE_DIRS})
target_link_libraries(my_app PRIVATE ${LIBYAML_LIBRARIES})
```

---

#### 3. FetchContent: Source-Level Dependency Management
**Key Concepts:**
- Downloads and builds dependencies during CMake configuration
- Ideal for header-only libraries or projects requiring source access
- Key commands:
  - `FetchContent_Declare()`: Define dependency source (Git, URL, etc.)
  - `FetchContent_MakeAvailable()`: Download and add to build

**Code Example: Fetch GoogleTest**
```cmake
include(FetchContent)

FetchContent_Declare(
  googletest
  GIT_REPOSITORY https://github.com/google/googletest.git
  GIT_TAG release-1.12.1
)

FetchContent_MakeAvailable(googletest)

add_executable(tests test.cpp)
target_link_libraries(tests PRIVATE gtest_main)
```

**Advantages:**
- No pre-installation required
- Version controlled via `GIT_TAG`/`URL_HASH`
- Automatic submodule handling

---

#### 4. ExternalProject: Build-Time Dependency Handling
**Key Concepts:**
- Downloads/built at build time (not during CMake configuration)
- Better for large dependencies with complex build systems
- Requires explicit build steps via `ExternalProject_Add()`

**Code Example: Build ZLIB**
```cmake
include(ExternalProject)

ExternalProject_Add(
  ZLIB
  URL https://zlib.net/zlib-1.2.13.tar.gz
  CMAKE_ARGS -DCMAKE_INSTALL_PREFIX=<INSTALL_DIR>
  BUILD_IN_SOURCE 0
  INSTALL_DIR ${CMAKE_BINARY_DIR}/zlib-install
)

# Make ZLIB available to main project
add_library(zlib STATIC IMPORTED)
set_target_properties(zlib PROPERTIES
  IMPORTED_LOCATION ${CMAKE_BINARY_DIR}/zlib-install/lib/libz.a
  INTERFACE_INCLUDE_DIRECTORIES ${CMAKE_BINARY_DIR}/zlib-install/include
)

add_dependencies(my_app ZLIB)
target_link_libraries(my_app PRIVATE zlib)
```

**Key Points:**
- Build occurs during `make`/`ninja` execution (not during CMake config)
- Requires careful path management for installed artifacts

---

#### 5. Real-World Example: YAML-CPP Integration
**Scenario:** Add YAML parsing to a project using both system and fetched versions.

**CMakeLists.txt:**
```cmake
# Try system installation first
find_package(yaml-cpp 0.7 QUIET)

if(NOT yaml-cpp_FOUND)
  # Fallback to FetchContent
  include(FetchContent)
  FetchContent_Declare(
    yaml-cpp
    URL https://github.com/jbeder/yaml-cpp/archive/yaml-cpp-0.7.0.tar.gz
    URL_HASH SHA256=43e6a9fcb146ad871515f0d0873947e5d497a1c9c60c58cb102a97b47208b7c3
  )
  FetchContent_MakeAvailable(yaml-cpp)
endif()

add_executable(yaml_test yaml_test.cpp)
target_link_libraries(yaml_test PRIVATE yaml-cpp)
```

**Explanation:**
1. Checks for system-installed yaml-cpp â‰¥0.7
2. If missing, downloads and builds from source
3. `yaml-cpp` target is consistent across both paths (modern CMake config)

---

#### 6. Critical Differences: FetchContent vs ExternalProject
| **Feature**               | `FetchContent`               | `ExternalProject`          |
|---------------------------|-------------------------------|----------------------------|
| **Timing**                | During CMake configuration    | During build phase         |
| **Source Availability**    | Immediate (subproject)        | Post-build only            |
| **Dependency Order**       | Main project depends on dep   | Dep built before main      |
| **Use Case**               | Small/medium deps, source access needed | Large deps, custom build steps |

---

#### 7. Common Pitfalls & Solutions
1. **Mixed Dependency Versions**  
   - Always specify exact versions in `FetchContent_Declare()`
   ```cmake
   GIT_TAG v2.4.1  # NOT "main" or "latest"
   ```

2. **Missing Transitive Dependencies**  
   - Prefer target-based linking over variables:
   ```cmake
   target_link_libraries(app PRIVATE LibYAML::LibYAML)  # Good
   # Instead of:
   include_directories(${LIBYAML_INCLUDE_DIRS})  # Avoid
   ```

3. **Build Type Mismatches**  
   - Ensure all dependencies use same build type (Debug/Release):
   ```cmake
   set(CMAKE_BUILD_TYPE Release CACHE STRING "" FORCE)
   ```

4. **Cross-Compiling Issues**  
   - Use toolchain files when fetching dependencies:
   ```cmake
   FetchContent_Declare(..., CMAKE_ARGS -DCMAKE_TOOLCHAIN_FILE=../arm-toolchain.cmake)
   ```

---

#### 8. Advanced Technique: Version Fallback
Implement tiered dependency resolution:
```cmake
# 1. Check system install
find_package(OpenSSL 3.0 QUIET)

# 2. Try vcpkg/conan
if(NOT OpenSSL_FOUND)
  find_package(OpenSSL 3.0 
    HINTS ${VCPKG_ROOT}/installed/x64-linux
    PATH_SUFFIXES lib/cmake
  )
endif()

# 3. Fallback to source build
if(NOT OpenSSL_FOUND)
  include(FetchContent)
  FetchContent_Declare(...)
endif()
```

---

#### Conclusion
Effective dependency management in CMake requires:
- Preferring modern `find_package()` with imported targets
- Using `FetchContent` for source-level control
- Resorting to `ExternalProject` for complex build pipelines
- Implementing robust fallback mechanisms
- Rigorous version pinning for reproducible builds

---

### Multiple-Choice Questions 

---

**Question 1**  
Which statements about `find_package()` are correct?  
A) It uses `Find<PackageName>.cmake` scripts in CONFIG mode  
B) `<PackageName>_FOUND` is set to `TRUE` if the package is found  
C) `CONFIG` mode requires `<PackageName>Config.cmake` files  
D) `REQUIRED` keyword enforces immediate failure if dependency is missing  

---

**Question 2**  
What are valid approaches to handle dependencies NOT found via `find_package()`?  
A) Use `FetchContent` to download source code during configuration  
B) Use `ExternalProject` to build dependencies during build stage  
C) Require users to manually install dependencies via system package manager  
D) Use `include()` to load precompiled binaries  

---

**Question 3**  
Which are TRUE about `FetchContent` vs. `ExternalProject`?  
A) `FetchContent` downloads dependencies during build stage  
B) `ExternalProject` supports patching via `PATCH_COMMAND`  
C) `FetchContent` populates dependencies at configure time  
D) `ExternalProject` executes commands at build time  

---

**Question 4**  
When writing custom `Find<PackageName>.cmake` modules:  
A) `find_path()` should set `<PackageName>_INCLUDE_DIRS`  
B) `find_library()` checks standard system paths by default  
C) `mark_as_advanced()` hides variables from CMake GUI  
D) `<PackageName>_LIBRARIES` must include transitive dependencies  

---

**Question 5**  
Which statements about dependency versioning are correct?  
A) `FetchContent` uses `GIT_TAG` to specify commit hashes  
B) `find_package()`'s `VERSION` argument enforces exact version matches  
C) `ExternalProject`'s `GIT_REPOSITORY` can use branches via `GIT_TAG`  
D) `FetchContent` automatically checks for updates if `GIT_SHALLOW` is used  

---

**Question 6**  
What are valid ways to handle components in dependencies?  
A) Use `COMPONENTS` keyword in `find_package()` for package-specific components  
B) `FetchContent` natively supports component-based dependencies  
C) `ExternalProject` uses `DEPENDS` to declare component relationships  
D) `FindPkgConfig` uses `--static` to handle static library components  

---

**Question 7**  
Which strategies help avoid conflicts between system and fetched dependencies?  
A) Use `NO_SYSTEM_ENVIRONMENT_PATH` in `find_package()`  
B) Set `FETCHCONTENT_TRY_FIND_PACKAGE_MODE` to `ALWAYS`  
C) Prioritize `FetchContent` over system packages via `OVERRIDE_FIND_PACKAGE`  
D) Use `EXCLUDE_FROM_ALL` in `ExternalProject`  

---

**Question 8**  
Which are TRUE about `FindPkgConfig`?  
A) Requires `.pc` files in `PKG_CONFIG_PATH`  
B) `pkg_check_modules()` sets `<PREFIX>_LIBRARIES` automatically  
C) Works best with modern CMake target-based dependencies  
D) Supports static/dynamic linking via `IMPORTED_TARGET`  

---

**Question 9**  
What correctly describes dependency propagation in CMake?  
A) `FetchContent` dependencies are automatically visible to parent projects  
B) `ExternalProject` requires explicit `install()` steps to export targets  
C) `target_link_libraries()` propagates `INTERFACE` properties  
D) `find_package()`-discovered targets support transitive usage requirements  

---

**Question 10**  
Which are valid patterns for hybrid dependency management?  
A) Use `find_package()` first, fallback to `FetchContent` if unavailable  
B) Combine `FetchContent` with `find_package()` via `OVERRIDE_FIND_PACKAGE`  
C) Use `ExternalProject` for cross-platform compilation toolchains  
D) Force `FetchContent` to use system paths via `SOURCE_DIR`  

---

### Answers & Explanations

---

**Question 1**  
**Correct Answers:** B, C, D  
- **B)** Correct: `<PackageName>_FOUND` indicates successful discovery.  
- **C)** Correct: CONFIG mode relies on `<PackageName>Config.cmake`.  
- **D)** Correct: `REQUIRED` ensures immediate failure if missing.  
- **A)** Incorrect: `Find<PackageName>.cmake` is used in MODULE mode, not CONFIG.  

---

**Question 2**  
**Correct Answers:** A, B  
- **A)** Correct: `FetchContent` downloads during configuration.  
- **B)** Correct: `ExternalProject` builds during the build stage.  
- **C)** Incorrect: Manual installation violates automation goals.  
- **D)** Incorrect: `include()` does not manage precompiled binaries.  

---

**Question 3**  
**Correct Answers:** B, C, D  
- **B)** Correct: `ExternalProject` supports patching.  
- **C)** Correct: `FetchContent` populates at configure time.  
- **D)** Correct: `ExternalProject` runs commands during build.  
- **A)** Incorrect: `FetchContent` runs at configure time, not build.  

---

**Question 4**  
**Correct Answers:** A, B, C  
- **A)** Correct: `find_path()` sets include directories.  
- **B)** Correct: `find_library()` checks standard paths.  
- **C)** Correct: `mark_as_advanced()` hides GUI variables.  
- **D)** Incorrect: Transitive dependencies are handled via `INTERFACE` properties, not manual inclusion.  

---

**Question 5**  
**Correct Answers:** A, C  
- **A)** Correct: `GIT_TAG` specifies commits/branches.  
- **C)** Correct: `GIT_TAG` in `ExternalProject` can reference branches.  
- **B)** Incorrect: `VERSION` checks compatibility but allows newer versions.  
- **D)** Incorrect: `GIT_SHALLOW` enables shallow clones but does not auto-update.  

---

**Question 6**  
**Correct Answers:** A, D  
- **A)** Correct: `COMPONENTS` specifies required parts (e.g., Boost components).  
- **D)** Correct: `--static` with `FindPkgConfig` handles static linking.  
- **B)** Incorrect: `FetchContent` does not natively support components.  
- **C)** Incorrect: `DEPENDS` declares build order, not components.  

---

**Question 7**  
**Correct Answers:** A, C  
- **A)** Correct: `NO_SYSTEM_ENVIRONMENT_PATH` skips system paths.  
- **C)** Correct: `OVERRIDE_FIND_PACKAGE` prioritizes `FetchContent`.  
- **B)** Incorrect: `ALWAYS` forces `find_package()` to fail, which is counterproductive.  
- **D)** Incorrect: `EXCLUDE_FROM_ALL` controls build inclusion, not conflicts.  

---

**Question 8**  
**Correct Answers:** A, D  
- **A)** Correct: `.pc` files must be in `PKG_CONFIG_PATH`.  
- **D)** Correct: `IMPORTED_TARGET` enables target-based usage.  
- **B)** Incorrect: `pkg_check_modules()` sets `<PREFIX>_LIBRARIES`, not `<PREFIX>_LIBRARIES`.  
- **C)** Incorrect: `FindPkgConfig` is legacy and less integrated with modern targets.  

---

**Question 9**  
**Correct Answers:** C, D  
- **C)** Correct: `target_link_libraries()` propagates `INTERFACE` properties.  
- **D)** Correct: Targets from `find_package()` support transitive usage.  
- **A)** Incorrect: `FetchContent` dependencies are isolated unless exported.  
- **B)** Incorrect: `ExternalProject` does not require `install()` for internal use.  

---

**Question 10**  
**Correct Answers:** A, B, C  
- **A)** Correct: Check system first, then fetch.  
- **B)** Correct: Override `find_package()` with fetched content.  
- **C)** Correct: `ExternalProject` is ideal for toolchains.  
- **D)** Incorrect: `SOURCE_DIR` specifies location but does not force system paths.  

---
### CMake Build Problems

---

**Problem 1: Custom Find Module with Version Constraints**
**Scenario**:  
Create a custom `FindLibXml2.cmake` module to locate a system-installed LibXml2 library. The module must:
1. Search for headers in standard `/usr/include/libxml2` and libraries in `/usr/lib`.
2. Validate that the detected version is â‰¥ 2.9.4.
3. Define an imported target `LibXml2::LibXml2` with proper `INTERFACE_INCLUDE_DIRECTORIES` and `IMPORTED_LOCATION` properties.
4. Set `LIBXML2_FOUND` appropriately and fail gracefully if requirements arenâ€™t met.

**Challenge**:  
How would you extract the version from `libxml2`â€™s installed headers and enforce semantic versioning?

---

**Problem 2: Hybrid Dependency Resolution with FetchContent**
**Scenario**:  
Your project depends on `yaml-cpp`, but you must:
1. Prefer a system-installed version via `find_package(yaml-cpp 0.7.0 REQUIRED)`.
2. If unavailable, fetch `yaml-cpp` from GitHub (https://github.com/jbeder/yaml-cpp) at tag `yaml-cpp-0.7.0` using `FetchContent`.
3. Apply a patch to fix a compilation error in the fetched source (assume `fix.patch` exists locally).
4. Ensure downstream targets link to `yaml-cpp` correctly via `target_link_libraries`.

**Challenge**:  
How would you conditionally override `FetchContent` to avoid conflicts with a system-installed version, and apply patches only when fetching?

---

**Problem 3: Transitive Dependencies with ExternalProject**
**Scenario**:  
Your project depends on `LibraryA`, which in turn depends on `LibraryB`. Neither uses CMake. Using `ExternalProject_Add`:
1. Build `LibraryB` first, configure it with `--prefix=${CMAKE_BINARY_DIR}/deps`.
2. Build `LibraryA` with `--with-libraryB=${CMAKE_BINARY_DIR}/deps`.
3. Ensure your final executable links to both libraries.
4. Avoid hardcoding build commands; use platform-agnostic CMake logic.

**Challenge**:  
How would you enforce build order between `LibraryA` and `LibraryB`, and propagate include paths and library locations from `LibraryB` to `LibraryA`?

---

### Solutions & Explanations

---

**Problem 1 Solution**
**FindLibXml2.cmake**:
```cmake
include(FindPackageHandleStandardArgs)

# Find headers and library
find_path(LIBXML2_INCLUDE_DIR libxml/parser.h
    PATHS /usr/include/libxml2
)
find_library(LIBXML2_LIBRARY NAMES xml2 libxml2)

# Extract version from header
if(LIBXML2_INCLUDE_DIR)
    file(STRINGS "${LIBXML2_INCLUDE_DIR}/libxml/xmlversion.h" _version_line
        REGEX "#define LIBXML_DOTTED_VERSION"
    )
    string(REGEX REPLACE ".*\"([0-9]+\\.[0-9]+\\.[0-9]+)\".*" "\\1" LIBXML2_VERSION "${_version_line}")
endif()

# Validate version
if(LIBXML2_VERSION VERSION_LESS "2.9.4")
    message(FATAL_ERROR "LibXml2 version >= 2.9.4 required (found ${LIBXML2_VERSION})")
endif()

# Define imported target
if(NOT TARGET LibXml2::LibXml2)
    add_library(LibXml2::LibXml2 UNKNOWN IMPORTED)
    set_target_properties(LibXml2::LibXml2 PROPERTIES
        INTERFACE_INCLUDE_DIRECTORIES "${LIBXML2_INCLUDE_DIR}"
        IMPORTED_LOCATION "${LIBXML2_LIBRARY}"
    )
endif()

# Finalize
find_package_handle_standard_args(LibXml2
    REQUIRED_VARS LIBXML2_LIBRARY LIBXML2_INCLUDE_DIR
    VERSION_VAR LIBXML2_VERSION
)
```

**Explanation**:
- **Version Extraction**: Parses `xmlversion.h` to extract `LIBXML_DOTTED_VERSION` using regex.
- **Imported Target**: Creates a target with include directories and library location, enabling modern `target_link_libraries` usage.
- **Version Check**: Uses `VERSION_LESS` to enforce minimum version, failing explicitly if unmet.

---

**Problem 2 Solution**
**CMakeLists.txt**:
```cmake
cmake_minimum_required(VERSION 3.14)
project(MyProject)

# Try system installation first
find_package(yaml-cpp 0.7.0 QUIET)

if(NOT yaml-cpp_FOUND)
    include(FetchContent)
    FetchContent_Declare(
        yaml-cpp
        URL https://github.com/jbeder/yaml-cpp/archive/refs/tags/yaml-cpp-0.7.0.tar.gz
        PATCH_COMMAND git apply ${CMAKE_CURRENT_SOURCE_DIR}/fix.patch
    )
    FetchContent_MakeAvailable(yaml-cpp)
    
    # Avoid conflicts: mark headers as system includes
    target_include_directories(yaml-cpp SYSTEM PUBLIC $<BUILD_INTERFACE:${yaml-cpp_SOURCE_DIR}/include>)
endif()

add_executable(MyApp main.cpp)
target_link_libraries(MyApp PRIVATE yaml-cpp)
```

**Explanation**:
- **Conditional Fetching**: `find_package` checks for a system install first. Only if missing, `FetchContent` downloads the library.
- **Patching**: Uses `PATCH_COMMAND` to apply fixes to fetched sources.
- **System Includes**: Marks includes as `SYSTEM` to suppress compiler warnings from third-party code.

---

**Problem 3 Solution**
**CMakeLists.txt**:
```cmake
cmake_minimum_required(VERSION 3.14)
project(MyProject)

include(ExternalProject)

# Build LibraryB
ExternalProject_Add(
    LibraryB
    URL https://example.com/libraryb-1.0.tar.gz
    CONFIGURE_COMMAND <SOURCE_DIR>/configure --prefix=${CMAKE_BINARY_DIR}/deps
    BUILD_COMMAND make
    INSTALL_COMMAND make install
)

# Build LibraryA (depends on LibraryB)
ExternalProject_Add(
    LibraryA
    URL https://example.com/librarya-2.0.tar.gz
    DEPENDS LibraryB
    CONFIGURE_COMMAND <SOURCE_DIR>/configure --with-libraryB=${CMAKE_BINARY_DIR}/deps
    BUILD_COMMAND make
    INSTALL_COMMAND make install
)

# Main executable
add_executable(MyApp main.cpp)
add_dependencies(MyApp LibraryA)

# Link against installed libraries
target_link_libraries(MyApp
    PRIVATE ${CMAKE_BINARY_DIR}/deps/lib/libLibraryA.a
            ${CMAKE_BINARY_DIR}/deps/lib/libLibraryB.a
)
target_include_directories(MyApp PRIVATE ${CMAKE_BINARY_DIR}/deps/include)
```

**Explanation**:
- **Build Order**: `DEPENDS LibraryB` ensures `LibraryA` builds after `LibraryB`.
- **Path Propagation**: Uses `--prefix` and `--with-libraryB` to pass installation paths between projects.
- **Linking**: Directly links to the installed static libraries and includes headers from the custom prefix.

---

**Key Takeaways**:
1. **Find Modules** require careful handling of paths, version checks, and target creation for modern CMake compatibility.
2. **FetchContent + find_package Hybrid** leverages system installations when possible while allowing patches for fetched sources.
3. **ExternalProject_Add** manages complex build orders and dependencies for non-CMake projects, requiring explicit path management.